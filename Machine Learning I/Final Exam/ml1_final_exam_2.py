# -*- coding: utf-8 -*-
"""ML1 Final Exam 2.py

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1pa_EMeva3-IyML7yjK_m4oyPDnqU1ITR
"""

import pandas as pd
import numpy as np
from sklearn.model_selection import train_test_split, cross_val_score
from sklearn.preprocessing import StandardScaler, LabelEncoder, OneHotEncoder
from sklearn.compose import ColumnTransformer
from sklearn.ensemble import RandomForestClassifier, VotingClassifier
from sklearn.svm import SVC
from sklearn.linear_model import LogisticRegression
from sklearn.naive_bayes import GaussianNB
from sklearn.neighbors import KNeighborsClassifier
from sklearn.feature_selection import SelectKBest, f_classif
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
import warnings

warnings.filterwarnings("ignore")

def main():
    # Load the dataset
    df = pd.read_csv("https://raw.githubusercontent.com/subashgandyer/datasets/main/great_customers.csv")

    # Drop duplicate rows if any
    df = df.drop_duplicates()

    # Handle missing values
    df = df.dropna()

    print("drop all missing values")

    # Drop the unique identifier column (assuming it's the first column)
    df = df.iloc[:, 1:]

    # Encode categorical target variable
    label_encoder = LabelEncoder()
    df['great_customer_class'] = label_encoder.fit_transform(df['great_customer_class'])

    # Identify categorical columns for one-hot encoding
    categorical_features = ["workclass", "salary", "education_rank", "marital-status", "occupation", "race", "sex"]

    # Apply one-hot encoding
    column_transformer = ColumnTransformer([
        ('one_hot', OneHotEncoder(drop='first', sparse_output=False), categorical_features)
    ], remainder='passthrough')

    X = df.drop(columns=['great_customer_class'])
    y = df['great_customer_class']

    X_transformed = column_transformer.fit_transform(X)

    print("Apply one-hot encoding")

    # Feature selection
    selector = SelectKBest(score_func=f_classif, k=5)  # Selecting top 5 features
    X_new = selector.fit_transform(X_transformed, y)

    print(f"Selected features: 5")

    # Train-test split
    X_train, X_test, y_train, y_test = train_test_split(X_new, y, test_size=0.2, random_state=42, stratify=y)

    # Standardizing the features
    scaler = StandardScaler()
    X_train = scaler.fit_transform(X_train)
    X_test = scaler.transform(X_test)

    # Initialize models
    models = {
        "Random Forest": RandomForestClassifier(n_estimators=50, max_depth=10, random_state=42, n_jobs=-1),
        "SVM": SVC(kernel='rbf', C=0.5, probability=True, random_state=42),
        "Logistic Regression": LogisticRegression(solver='liblinear', random_state=42),
        "Naive Bayes": GaussianNB(),
        "KNN": KNeighborsClassifier(n_neighbors=3, algorithm='ball_tree')
    }

    # Train and evaluate models
    for name, model in models.items():
        model.fit(X_train, y_train)
        y_pred = model.predict(X_test)
        accuracy = accuracy_score(y_test, y_pred)
        print(f"Accuracy of {name}: {accuracy:.4f}")

    # Ensemble learning using Voting Classifier
    voting_clf = VotingClassifier(
        estimators=[
            ("Random Forest", models["Random Forest"]),
            ("SVM", models["SVM"]),
            ("Logistic Regression", models["Logistic Regression"]),
            ("Naive Bayes", models["Naive Bayes"]),
            ("KNN", models["KNN"])
        ], voting='hard'
    )

    # Train and evaluate ensemble model
    voting_clf.fit(X_train, y_train)
    y_pred_ensemble = voting_clf.predict(X_test)
    ensemble_accuracy = accuracy_score(y_test, y_pred_ensemble)
    print(f"Accuracy of Ensemble Model (Voting Classifier): {ensemble_accuracy:.4f}")

    # Confusion Matrix and Classification Report
    conf_matrix = confusion_matrix(y_test, y_pred_ensemble)
    class_report = classification_report(y_test, y_pred_ensemble)
    print("Confusion Matrix:")
    print(conf_matrix)
    print("Classification Report:")
    print(class_report)

if __name__ == "__main__":
    main()